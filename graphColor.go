package aojia

import (
	"unsafe"

	"github.com/go-ole/go-ole"
)

type _bytes struct {
	Data int
	Len  int
}

/*
函数功能: 将图像数据的地址添加到字符串中

函数原型: 字符串 AddPicAddr(PicAddrS, Addr)

参数说明:
PicAddrS: 字符串,要加入数据地址的字符串,第一次调用这个函数时可以设为空

Addr: 64位长整数,图像数据的地址

返回值: 字符串,返回添加数据地址后的字符串,失败返回空

示例:

	  LLAJD = AJ.GetScreenDataBmp(x1, y1, x2, y2, L"", Size);
	  SA = AJ.AddPicAddr(L"", LLAJD); cout << "SA: " << SA << endl;
	这个函数返回的字符串可以做为函数FindPicM,FindPicMEx,FindPicDM,FindPicDMEx的参数PicAddr的值
*/
func (com *AJsoft) AddPicAddr(PicAddrS string, Addr int64) string {
	ret, _ := com.aj.CallMethod("AddPicAddr", PicAddrS, Addr)
	// fmt.Printf("strconv.Itoa(int(ret.Val)): %v\n", strconv.Itoa(int(ret.Val)))

	return ret.ToString()
}

/*
函数功能: BGR与RGB的颜色格式相互转换,如果传入的颜色格式是BGR,则把BGR的颜色格式转换为RGB的颜色格式,如果传入的颜色格式是RGB,则把RGB的颜色格式转换为BGR的颜色格式

函数原型: 字符串 BGRorRGB(Color)

参数说明:
Color: 字符串,BGR或RGB颜色格式的字符串,字符数必须是6个,且字符必须都是16进制数的数码,英文字母大小写都可以

返回值: 字符串,BGR或RGB颜色格式的字符串

示例:
S = AJ.BGRorRGB("123456") : TracePrint S
S = AJ.BGRorRGB("563412") : TracePrint S
*/
func (com *AJsoft) BGRorRGB(Color string) string {
	ret, _ := com.aj.CallMethod("BGRorRGB", Color)
	return ret.ToString()
}

/*
函数功能: 将BGR或RGB的颜色格式转换为HSV的颜色格式

函数原型: 字符串 BGRorRGBtoHSV(Color, Type)

参数说明:
Color: 字符串,BGR或RGB颜色格式的字符串,字符数必须是6个,且字符必须都是16进制数的数码,英文字母大小写都可以

Type: 整数,指定Color是BGR颜色格式还是RGB颜色格式,取值只能是0或1,为0表示把Color当成BGR的颜色格式,为1表示把Color当成RGB的颜色格式

返回值: 字符串,返回HSV颜色格式的字符串

示例:
AJD = AJ.BGRorRGBtoHSV("123456", 0) : TracePrint AJD
AJD = AJ.BGRorRGBtoHSV("563412", 1) : TracePrint AJD
*/
func (com *AJsoft) BGRorRGBtoHSV(Color string, Type int) string {
	ret, _ := com.aj.CallMethod("BGRorRGBtoHSV", Color, Type)
	return ret.ToString()
}

/*
函数功能: 比较指定坐标点(x,y)的颜色

函数原型: 整数 CmpColor(x, y, Color, Sim, Type)

参数说明:
x: 整数,坐标点横坐标

y: 整数,坐标点纵坐标

Color: 字符串,要比较的颜色,支持偏色,多色,格式为"BBGGRR-DBDGDR|BBGGRR-DBDGDR|BBGGRR-DBDGDR|……",颜色数量不限

Sim: 双精度浮点数,颜色相似度,取值范围是[0, 1.0]

Type: 整数,取值只能是0或1,0表示不用截图的方式获取颜色,1表示使用截图的方式获取颜色,Type为0只能比对桌面或后台窗口像素的颜色,Type为1还可以比对用SetPCData设置的图片的像素的颜色.

返回值: 整数,返回匹配的颜色序号,颜色序号按颜色组合中颜色从左到右的顺序从0开始进行编号,所有颜色都不匹配返回-1

示例:
AJD = AJ.CmpColor(100, 600, "010101-101010|232300-000000|333300-000000", 0.9, 0) : TracePrint AJD
AJD = AJ.CmpColor(666, 666, "FFFFFF-101010|abcdef-000000|000000-000000", 1.0, 1) : TracePrint AJD
*/
func (com *AJsoft) CmpColor(x, y int, Color string, Sim float64, Type int) int {
	ret, _ := com.aj.CallMethod("CmpColor", x, y, Color, Sim, Type)
	return int(int32(ret.Val))
}

/*
函数功能: 在指定的区域内查找颜色

函数原型: 整数 FindColor(x1, y1, x2, y2, Color, Sim, Dir, x, y)

参数说明:
x1: 整数,区域左上角的横坐标

y1: 整数,区域左上角的纵坐标

x2: 整数,区域右下角的横坐标

y2: 整数,区域右下角的纵坐标

Color: 字符串,要查找的颜色,支持偏色,多色,格式为"BBGGRR-DBDGDR|BBGGRR-DBDGDR|BBGGRR-DBDGDR|……",颜色数量不限

Sim: 双精度浮点数,颜色相似度,取值范围是[0, 1.0]

Dir: 整数,查找方向,只能是下面列出的值之一:

0: 从左到右,从上到下
1: 从左到右,从下到上
2: 从右到左,从上到下
3: 从右到左,从下到上
4: 从中心往外以顺时针螺旋方式查找
5: 从上到下,从左到右
6: 从上到下,从右到左
7: 从下到上,从左到右
8: 从下到上,从右到左
9: 如果你需要的结果不需要考虑查找方向,而只要在查找区域内找到就行,那建议将查找方向设置为这个值,这样函数会选择最快的方式查找,虽然不是所有情况,但很多情况下这种查找方式比其它方式快,并且在任何情况下都不会比其它方式慢
x: 变体指针,返回找到的颜色的横坐标,没找到返回-1

y: 变体指针,返回找到的颜色的纵坐标,没找到返回-1

返回值: 整数,返回第一个找到的颜色的序号,颜色序号按颜色组合中颜色从左到右的顺序从0开始进行编号,所有颜色都没找到返回-1

示例:
AJD = AJ.FindColor(100, 100, 1000, 1000, "E8A200-000000", 0.93, 0, x, y) : TracePrint AJD & " --> " & x & " , " & y
AJ.FindColor 0, 0, 1919, 1079, "FFFFFF-000000|ED1C24-000000", 1.0, 9, x, y : TracePrint x & " , " & y
*/
func (com *AJsoft) FindColor(x1, y1, x2, y2 int, Color string, Sim float64, Dir int, x, y *int) int {
	nvX := ole.NewVariant(ole.VT_I4, int64(*x))
	nvY := ole.NewVariant(ole.VT_I4, int64(*y))

	ret, _ := com.aj.CallMethod("FindColor", x1, y1, x2, y2, Color, Sim, Dir, &nvX, &nvY)

	*x = int(int32(nvX.Val))
	*y = int(int32(nvY.Val))

	nvX.Clear()
	nvY.Clear()

	return int(int32(ret.Val))
}

/*
函数功能: 在指定的区域内查找颜色

函数原型: 字符串 FindColorEx(x1, y1, x2, y2, Color, Sim, Dir)

参数说明:
x1: 整数,区域左上角的横坐标

y1: 整数,区域左上角的纵坐标

x2: 整数,区域右下角的横坐标

y2: 整数,区域右下角的纵坐标

Color: 字符串,要查找的颜色,支持偏色,多色,格式为"BBGGRR-DBDGDR|BBGGRR-DBDGDR|BBGGRR-DBDGDR|……",颜色数量不限

Sim: 双精度浮点数,颜色相似度,取值范围是[0, 1.0]

Dir: 整数,查找方向,只能是下面列出的值之一:

0: 从左到右,从上到下
1: 从左到右,从下到上
2: 从右到左,从上到下
3: 从右到左,从下到上
4: 从中心往外以顺时针螺旋方式查找
5: 从上到下,从左到右
6: 从上到下,从右到左
7: 从下到上,从左到右
8: 从下到上,从右到左
9: 如果你需要的结果不需要考虑查找方向,而只要在查找区域内找到就行,那建议将查找方向设置为这个值,这样函数会选择最快的方式查找,虽然不是所有情况,但很多情况下这种查找方式比其它方式快,并且在任何情况下都不会比其它方式慢
返回值: 字符串,返回找到的颜色的所有带序号的坐标,格式为"序号,x,y|序号,x,y|序号,x,y|……",颜色序号按颜色组合中颜色从左到右的顺序从0开始进行编号,所有颜色都没找到返回空.当查找方向的值为9时函数最多返回2001个坐标,查找方向的值不为9时最多返回3999个坐标.

示例:
AJD = AJ.FindColorEx(100, 100, 1000, 1000, "E8A200-000000", 0.93, 0) : TracePrint AJD
AJD = AJ.FindColorEx(0, 0, 4, 4, "808080-808080", 0.93, 9) : TracePrint AJD
*/
func (com *AJsoft) FindColorEx(x1, y1, x2, y2 int, Color string, Sim float64, Dir int) string {
	ret, _ := com.aj.CallMethod("FindColorEx", x1, y1, x2, y2, Color, Sim, Dir)
	return ret.ToString()
}

/*
函数功能: 在指定区域内查找所有或部分颜色

函数原型: 整数 FindColorM(x1, y1, x2, y2, Color, Sim, Count)

参数说明:
x1: 整数,区域左上角的横坐标

y1: 整数,区域左上角的纵坐标

x2: 整数,区域右下角的横坐标

y2: 整数,区域右下角的纵坐标

Color: 字符串,要查找的颜色,支持偏色,多色,格式为"BBGGRR-DBDGDR|BBGGRR-DBDGDR|BBGGRR-DBDGDR|……",颜色数量不限

Sim: 双精度浮点数,颜色相似度,取值范围是[0, 1.0]

Count: 整数,Count是函数返回1表示找到所需的最小颜色数量,取值范围是: 0 <= Count <= 传递的颜色组合数量. 比如传递了5种颜色组合,将Count设为3,表示只要在指定区域内找到5种颜色中的任意3种函数就返回1表示找到,否则返回0表示没找到.如果要找到所有颜色才返回1,可将Count设为0或传递的颜色组合数量,设为0就不要你去数传递了多少种颜色了

返回值: 整数,返回1表示找到,0表示没找到

示例:
AJD = AJ.FindColorM(38, 774, 180, 916, "FFFFFF-000000|E8A210-000000|277FF1-000000|4CB121-000000|241CE1-000000", 1.0, 3) : TracePrint AJD
AJD = AJ.FindColorM(38, 774, 180, 916, "FFFFFF-000000|E8A210-000000", 1.0, 2) : TracePrint AJD
AJD = AJ.FindColorM(100, 100, 200, 200, "FFFFFF-000000|E8A210-000000|ED1C24-000000", 0.9, 0) : TracePrint AJD
*/
func (com *AJsoft) FindColorM(x1, y1, x2, y2 int, Color string, Sim float64, Count int) int {
	ret, _ := com.aj.CallMethod("FindColorM", x1, y1, x2, y2, Color, Sim, Count)
	return int(ret.Val)
}

/*
函数功能: 在指定的区域内查找色块

函数原型: 整数 FindColorSqu(x1, y1, x2, y2, Color, Sim, SimD, Dir, Width, Height, x, y)

参数说明:
x1: 整数,区域左上角的横坐标

y1: 整数,区域左上角的纵坐标

x2: 整数,区域右下角的横坐标

y2: 整数,区域右下角的纵坐标

Color: 字符串,要查找的色块的颜色,支持偏色,多色,格式为"BBGGRR-DBDGDR|BBGGRR-DBDGDR|BBGGRR-DBDGDR|……",颜色数量不限

Sim: 双精度浮点数,颜色相似度,取值范围是[0, 1.0]

SimD: 双精度浮点数,点阵相似度,取值范围是(0, 1.0]. Width * Height * SimD表示找到色块所需的最小像素数量,比如一个宽和高分别为10 * 10的色块总共有100个像素点,而SimD设为0.9,只要在查找区域的任何一个10 * 10区域内找到90个颜色符合Color和Sim的像素点,函数就返回1表示找到,并且返回这个10 * 10区域的左上角坐标.

Dir: 整数,查找方向,只能是下面列出的值之一:

0: 从左到右,从上到下
1: 从左到右,从下到上
2: 从右到左,从上到下
3: 从右到左,从下到上
4: 从中心往外以顺时针螺旋方式查找,当查找区域比色块大得多时效果才明显
5: 从上到下,从左到右
6: 从上到下,从右到左
7: 从下到上,从左到右
8: 从下到上,从右到左
9: 如果你需要的结果不需要考虑查找方向,而只要在查找区域内找到就行,那建议将查找方向设置为这个值,这样函数会选择最快的方式查找,虽然不是所有情况,但很多情况下这种查找方式比其它方式快,并且在任何情况下都不会比其它方式慢
Width: 整数,色块的宽度,取值范围是(0, x2 - x1 + 1]

Height: 整数,色块的高度,取值范围是(0, y2 - y1 + 1]

x: 变体指针,返回找到的色块左上角的横坐标,没找到返回-1

y: 变体指针,返回找到的色块左上角的纵坐标,没找到返回-1

返回值: 整数,返回1表示找到,0表示没找到

示例:
AJD = AJ.FindColorSqu(0, 0, 1919, 1079, "FF0000-000000", 1.0, 1.0, 0, 10, 10, x, y) : TracePrint AJD & " --> " & x & " , " & y
AJD = AJ.FindColorSqu(0, 0, 1919, 1079, "FF0000-000000|ED1C24-102030", 0.9, 0.31, 9, 100, 200, x, y) : TracePrint AJD & " --> " & x & " , " & y
*/
func (com *AJsoft) FindColorSqu(x1, y1, x2, y2 int, Color string, Sim, SimD float64, Dir, Width, Height int, x, y *int) int {

	nvX := ole.NewVariant(ole.VT_I4, int64(*x))
	nvY := ole.NewVariant(ole.VT_I4, int64(*y))

	ret, _ := com.aj.CallMethod("FindColorSqu", x1, y1, x2, y2, Color, Sim, SimD, Dir, Width, Height, &nvX, &nvY)

	*x = int(int32(nvX.Val))
	*y = int(int32(nvY.Val))

	nvX.Clear()
	nvY.Clear()

	return int(ret.Val)
}

/*
函数功能: 在指定的区域内查找色块

函数原型: 字符串 FindColorSquEx(x1, y1, x2, y2, Color, Sim, SimD, Dir, Width, Height)

参数说明:
x1: 整数,区域左上角的横坐标

y1: 整数,区域左上角的纵坐标

x2: 整数,区域右下角的横坐标

y2: 整数,区域右下角的纵坐标

Color: 字符串,要查找的色块的颜色,支持偏色,多色,格式为"BBGGRR-DBDGDR|BBGGRR-DBDGDR|BBGGRR-DBDGDR|……",颜色数量不限

Sim: 双精度浮点数,颜色相似度,取值范围是[0, 1.0]

SimD: 双精度浮点数,点阵相似度,取值范围是(0, 1.0]. Width * Height * SimD表示找到色块所需的最小像素数量,比如一个宽和高分别为10 * 10的色块总共有100个像素点,而SimD设为0.9,只要在查找区域的任何一个10 * 10区域内找到90个颜色符合Color和Sim的像素点,函数就返回1表示找到,并且返回这个10 * 10区域的左上角坐标.

Dir: 整数,查找方向,只能是下面列出的值之一:

0: 从左到右,从上到下
1: 从左到右,从下到上
2: 从右到左,从上到下
3: 从右到左,从下到上
4: 从中心往外以顺时针螺旋方式查找,当查找区域比色块大得多时效果才明显
5: 从上到下,从左到右
6: 从上到下,从右到左
7: 从下到上,从左到右
8: 从下到上,从右到左
9: 如果你需要的结果不需要考虑查找方向,而只要在查找区域内找到就行,那建议将查找方向设置为这个值,这样函数会选择最快的方式查找,虽然不是所有情况,但很多情况下这种查找方式比其它方式快,并且在任何情况下都不会比其它方式慢
Width: 整数,色块的宽度,取值范围是(0, x2 - x1 + 1]

Height: 整数,色块的高度,取值范围是(0, y2 - y1 + 1]

返回值: 字符串,返回所有找到的色块的坐标,格式为"x,y|x,y|x,y|……",一个色块都没找到返回空,最多返回2000个坐标,

示例:
AJD = AJ.FindColorSquEx(0, 0, 1919, 1079, "FF0000-000000", 1.0, 1.0, 0, 10, 10) : TracePrint AJD
AJD = AJ.FindColorSquEx(0, 0, 1919, 1079, "FF0000-000000|ED1C24-102030", 0.9, 0.31, 9, 100, 200) : TracePrint AJD
*/
func (com *AJsoft) FindColorSquEx(x1, y1, x2, y2 int, Color string, Sim, SimD float64, Dir, Width, Height int) string {
	ret, _ := com.aj.CallMethod("FindColorSquEx", x1, y1, x2, y2, Color, Sim, SimD, Dir, Width, Height)
	return ret.ToString()
}

/*
函数功能: 在指定的区域内查找多点颜色

函数原型: 整数 FindMultiColor(x1, y1, x2, y2, Color, ColorP, Sim, Dir, SimP, SimD, x, y)

参数说明:
x1: 整数,区域左上角的横坐标

y1: 整数,区域左上角的纵坐标

x2: 整数,区域右下角的横坐标

y2: 整数,区域右下角的纵坐标

Color: 字符串,要查找的第一个点的颜色,支持偏色,多色,格式为"BBGGRR-DBDGDR|BBGGRR-DBDGDR|BBGGRR-DBDGDR|……",颜色数量不限.所有偏移点的坐标都相对于找到的第一个点的坐标

ColorP: 字符串,所有偏移点的坐标和颜色,支持偏色,多色,格式为"x1|y1|BBGGRR-DBDGDR|BBGGRR-DBDGDR|……,x2|y2|BBGGRR-DBDGDR|BBGGRR-DBDGDR|……,……,xn|yn|BBGGRR-DBDGDR|BBGGRR-DBDGDR|……",比如"-1|0|FFFFFF-000000|ED1C24-101010,1|3|123456-123456,-5|-4|666666-111111,6|8|FFF000-000000|000FFF-123321|456789-987654",支持反色,反色就是偏移点的颜色不在"BBGGRR-DBDGDR"加上考虑相似度表示的颜色集合中就能比对成功,反色的格式是"-BBGGRR-DBDGDR",也就是在BBGGRR-DBDGDR前加上一个"-"符号,比如"-1|0|-FFFFFF-000000|-ED1C24-101010,1|3|-123456-123456,-5|-4|-666666-111111,6|8|-FFF000-000000|-000FFF-123321|-456789-987654",格式"BBGGRR-DBDGDR"和反色格式"-BBGGRR-DBDGDR"中的偏色都不能省略,只有偏移点的颜色支持反色,第一个点的颜色不支持.函数只有在找到第一个点后才会相对第一个点的坐标去比对各偏移点的颜色是否匹配,偏移点的数量不限,每个偏移点的颜色组合数量也不限

Sim: 双精度浮点数,第一个点的颜色相似度,取值范围是[0, 1.0],函数用这个相似度在区域内查找第一个点

Dir: 整数,第一个点的查找方向,函数用这个查找方向查找第一个点的坐标,只能是下面列出的值之一:

0: 从左到右,从上到下
1: 从左到右,从下到上
2: 从右到左,从上到下
3: 从右到左,从下到上
4: 从中心往外以顺时针螺旋方式查找
5: 从上到下,从左到右
6: 从上到下,从右到左
7: 从下到上,从左到右
8: 从下到上,从右到左
9: 如果你需要的结果不需要考虑查找方向,而只要在查找区域内找到就行,那建议将查找方向设置为这个值,这样函数会选择最快的方式查找,虽然不是所有情况,但很多情况下这种查找方式比其它方式快,并且在任何情况下都不会比其它方式慢
SimP: 双精度浮点数,所有偏移点的颜色相似度,取值范围是[0, 1.0],函数用这个相似度比对所有偏移点的颜色是否匹配

SimD: 双精度浮点数,取值范围是(0, 1.0].用NumP表示ColorP中所有偏移点的数量,则NumP * SimD表示函数找到第一个点后比对偏移点成功所需的最小数量. 比如ColorP中有10个偏移点,而将SimD设为0.9,表示所有偏移点中只要有任意9个偏移点比对成功函数就能成功返回.

x: 变体指针,返回找到的第一个点的横坐标,没找到或找到后都没比对成功返回-1

y: 变体指针,返回找到的第一个点的纵坐标,没找到或找到后都没比对成功返回-1

返回值: 整数,返回找到的第一个点的颜色序号,颜色序号按第一个点的颜色组合中颜色从左到右的顺序从0开始进行编号,第一个点的所有颜色都没找到或找到后都没比对成功返回-1

示例:
AJD = AJ.FindMultiColor(0, 0, 1919, 1079, "FFFFFF-000000|666666-102010|456654-123321", "-1|0|FFFFFF-000000|ED1C24-101010,1|0|123456-123456,0|-1|666666-111111,0|1|FFF000-000000|000FFF-123321|456789-987654", 0.9, 0, 0.93, 1.0, x, y) : TracePrint AJD & " --> " & x & " , " & y
AJD = AJ.FindMultiColor(0, 0, 1919, 1079, "FFFFFF-000000|666666-102010|456654-123321", "-1|0|-FFFFFF-000000|-ED1C24-101010,1|3|-123456-123456,-5|-4|-666666-111111,6|8|-FFF000-000000|-000FFF-123321|-456789-987654", 1.0, 9, 1.0, 0.9, x, y) : TracePrint AJD & " --> " & x & " , " & y
*/
func (com *AJsoft) FindMultiColor(x1, y1, x2, y2 int, Color, ColorP string, Sim float64, Dir int, SimP, SimD float64, x, y *int) int {

	nvX := ole.NewVariant(ole.VT_I4, int64(*x))
	nvY := ole.NewVariant(ole.VT_I4, int64(*y))

	ret, _ := com.aj.CallMethod("FindMultiColor", x1, y1, x2, y2, Color, ColorP, Sim, Dir, SimP, SimD, &nvX, &nvY)

	*x = int(int32(nvX.Val))
	*y = int(int32(nvY.Val))

	nvX.Clear()
	nvY.Clear()

	return int(int32(ret.Val))
}

/*
函数功能: 在指定的区域内查找多点颜色

函数原型: 字符串 FindMultiColorEx(x1, y1, x2, y2, Color, ColorP, Sim, Dir, SimP, SimD)

参数说明:
x1: 整数,区域左上角的横坐标

y1: 整数,区域左上角的纵坐标

x2: 整数,区域右下角的横坐标

y2: 整数,区域右下角的纵坐标

Color: 字符串,要查找的第一个点的颜色,支持偏色,多色,格式为"BBGGRR-DBDGDR|BBGGRR-DBDGDR|BBGGRR-DBDGDR|……",颜色数量不限.所有偏移点的坐标都相对于找到的第一个点的坐标

ColorP: 字符串,所有偏移点的坐标和颜色,支持偏色,多色,格式为"x1|y1|BBGGRR-DBDGDR|BBGGRR-DBDGDR|……,x2|y2|BBGGRR-DBDGDR|BBGGRR-DBDGDR|……,……,xn|yn|BBGGRR-DBDGDR|BBGGRR-DBDGDR|……",比如"-1|0|FFFFFF-000000|ED1C24-101010,1|3|123456-123456,-5|-4|666666-111111,6|8|FFF000-000000|000FFF-123321|456789-987654",支持反色,反色就是偏移点的颜色不在"BBGGRR-DBDGDR"加上考虑相似度表示的颜色集合中就能比对成功,反色的格式是"-BBGGRR-DBDGDR",也就是在BBGGRR-DBDGDR前加上一个"-"符号,比如"-1|0|-FFFFFF-000000|-ED1C24-101010,1|3|-123456-123456,-5|-4|-666666-111111,6|8|-FFF000-000000|-000FFF-123321|-456789-987654",格式"BBGGRR-DBDGDR"和反色格式"-BBGGRR-DBDGDR"中的偏色都不能省略,只有偏移点的颜色支持反色,第一个点的颜色不支持.函数只有在找到第一个点后才会相对第一个点的坐标去比对各偏移点的颜色是否匹配,偏移点的数量不限,每个偏移点的颜色组合数量也不限

Sim: 双精度浮点数,第一个点的颜色相似度,取值范围是[0, 1.0],函数用这个相似度在区域内查找第一个点

Dir: 整数,第一个点的查找方向,函数用这个查找方向查找第一个点的坐标,只能是下面列出的值之一:

0: 从左到右,从上到下
1: 从左到右,从下到上
2: 从右到左,从上到下
3: 从右到左,从下到上
4: 从中心往外以顺时针螺旋方式查找
5: 从上到下,从左到右
6: 从上到下,从右到左
7: 从下到上,从左到右
8: 从下到上,从右到左
9: 如果你需要的结果不需要考虑查找方向,而只要在查找区域内找到就行,那建议将查找方向设置为这个值,这样函数会选择最快的方式查找,虽然不是所有情况,但很多情况下这种查找方式比其它方式快,并且在任何情况下都不会比其它方式慢
SimP: 双精度浮点数,所有偏移点的颜色相似度,取值范围是[0, 1.0],函数用这个相似度比对所有偏移点的颜色是否匹配

SimD: 双精度浮点数,取值范围是(0, 1.0].用NumP表示ColorP中所有偏移点的数量,则NumP * SimD表示函数找到第一个点后比对偏移点成功所需的最小数量. 比如ColorP中有10个偏移点,而将SimD设为0.9,表示所有偏移点中只要有任意9个偏移点比对成功函数就能成功返回.

返回值: 字符串,返回所有找到的第一个点的带颜色序号的坐标,格式为"序号,x,y|序号,x,y|序号,x,y|……",颜色序号按第一个点的颜色组合中颜色从左到右的顺序从0开始进行编号,第一个点的所有颜色都没找到或找到后都没比对成功返回空.当查找方向的值为9时函数最多返回2001个坐标,查找方向的值不为9时最多返回3999个坐标.

示例:
AJD = AJ.FindMultiColorEx(0, 0, 1919, 1079, "FFFFFF-000000|666666-102010|456654-123321", "-1|0|FFFFFF-000000|ED1C24-101010,1|0|123456-123456,0|-1|666666-111111,0|1|FFF000-000000|000FFF-123321|456789-987654", 0.9, 0, 0.93, 1.0) : TracePrint AJD
AJD = AJ.FindMultiColorEx(0, 0, 1919, 1079, "FFFFFF-000000|666666-102010|456654-123321", "-1|0|-FFFFFF-000000|-ED1C24-101010,1|3|-123456-123456,-5|-4|-666666-111111,6|8|-FFF000-000000|-000FFF-123321|-456789-987654", 1.0, 9, 1.0, 0.9) : TracePrint AJD
*/
func (com *AJsoft) FindMultiColorEx(x1, y1, x2, y2 int, Color, ColorP string, Sim float64, Dir int, SimP, SimD float64) string {
	ret, _ := com.aj.CallMethod("FindMultiColorEx", x1, y1, x2, y2, Color, ColorP, Sim, Dir, SimP, SimD)
	return ret.ToString()
}

/*
函数功能: 在指定的区域内查找图片,图片必须是24位位图格式,支持找透明图,当参数Type的值设为1,图片的四个顶点颜色相同,图片的像素个数大于4且至少有一个像素的颜色是非透明色时,把图片当成透明图,4个顶点的颜色当成透明色.如果查找的图片超过2张可以根据处理器的情况调用SetThread函数设置更多的线程并行的查找多张图片.

函数原型: 整数 FindPic(x1, y1, x2, y2, PicName, ColorP, Sim, Dir, Type, Pic, x, y)

参数说明:
x1: 整数,区域左上角的横坐标

y1: 整数,区域左上角的纵坐标

x2: 整数,区域右下角的横坐标

y2: 整数,区域右下角的纵坐标

PicName: 字符串,包含路径的图片名称,如果设置了全局路径,则可以只给出图片名称,支持多张图片,绝对路径的格式为: "路径\PicName1.bmp|路径\PicName2.bmp|路径\PicName3.bmp|……", 相对路径的格式为: "PicName1.bmp|PicName2.bmp|PicName3.bmp|……",设置了全局路径后依然可以写成绝对路径的格式,并且可以绝对路径和相对路径任意组合

ColorP: 字符串,图片每个像素颜色的偏色,BGR格式为"DBDGDR",灰度格式在灰度值前面加"G",比如"G16",HSV格式在HSV值前面加"H",比如"H210.50.2"

Sim: 双精度浮点数,颜色相似度,取值范围是[0, 1.0],这个是位图像素颜色和查找区域中对应位置的像素颜色的相似度,不是点阵相似度,这个函数的点阵相似度默认为1.0

Dir: 整数,查找方向,只能是下面列出的值之一:

0: 从左到右,从上到下
1: 从左到右,从下到上
2: 从右到左,从上到下
3: 从右到左,从下到上
4: 从中心往外以顺时针螺旋方式查找,当查找区域比图片大得多时效果才明显
5: 从上到下,从左到右
6: 从上到下,从右到左
7: 从下到上,从左到右
8: 从下到上,从右到左
9: 如果你需要的结果不需要考虑查找方向,而只要在查找区域内找到就行,那建议将查找方向设置为这个值,这样函数会选择最快的方式查找,虽然不是所有情况,但很多情况下这种查找方式比其它方式快,并且在任何情况下都不会比其它方式慢
Type: 整数,取值只能是0或1,0表示一定不把图片当成透明图,1表示允许把四个顶点颜色相同且像素个数大于4还至少有一个像素的颜色是非透明色的图片当成透明图

Pic: 变体指针,返回找到的图片的名称,没找到返回空

x: 变体指针,返回找到的图片左上角的横坐标,没找到返回-1

y: 变体指针,返回找到的图片左上角的纵坐标,没找到返回-1

返回值: 整数,返回第一个找到的图片的序号,图片序号按PicName中图片名从左到右的顺序从0开始进行编号,所有图片都没找到返回-1

示例:

	  AJD = AJ.FindPic(0, 0, 1919, 1079, "C:\Pic\8.bmp", "000000", 1.0, 0, 0, P, x, y) : TracePrint AJD & " --> " & P & " --> " & x & " , " & y
	  AJD = AJ.FindPic(0, 0, 1919, 1079, "1.bmp|2.bmp", "101010", 0.9, 9, 1, P, x, y) : TracePrint AJD & " --> " & P & " --> " & x & " , " & y

	  AJD = AJ.FindPic(0, 0, 1919, 1079, L"C:\\Users\\Administrator\\Desktop\\1.bmp", L"000000", 1.0, 0, 0, P, x, y);  SAS = P; cout << AJD << " , " << SAS << " -> " << x << " , " << y << endl;
	如果图片用函数EncryptFile加密过,在调用此函数之前需要调用函数SetPicPw设置密码图片才能加载成功
*/
func (com *AJsoft) FindPic(x1, y1, x2, y2 int, PicName, ColorP string, Sim float64, Dir, Type int, Pic *string, x, y *int) int {

	nvX := ole.NewVariant(ole.VT_I4, int64(*x))
	nvY := ole.NewVariant(ole.VT_I4, int64(*y))

	nvP := ole.NewVariant(ole.VT_BSTR|ole.VT_BYREF, int64(uintptr(unsafe.Pointer(Pic))))

	ret, _ := com.aj.CallMethod("FindPic", x1, y1, x2, y2, PicName, ColorP, Sim, Dir, Type, &nvP, &nvX, &nvY)

	*x = int(int32(nvX.Val))
	*y = int(int32(nvY.Val))

	*Pic = nvP.ToString()

	nvX.Clear()
	nvY.Clear()

	return int(int32(ret.Val))
}

/*
函数功能: 在指定的区域内查找图片,图片必须是24位位图格式,支持找透明图,当参数Type的值设为1,图片的四个顶点颜色相同,图片的像素个数大于4且至少有一个像素的颜色是非透明色时,把图片当成透明图,4个顶点的颜色当成透明色.如果需要可以根据处理器的情况调用SetThread函数设置更多的线程并行的进行查找.

函数原型: 整数 FindPicD(x1, y1, x2, y2, PicName, ColorP, Sim, SimD, Dir, Type, Pic, x, y)

参数说明:
x1: 整数,区域左上角的横坐标

y1: 整数,区域左上角的纵坐标

x2: 整数,区域右下角的横坐标

y2: 整数,区域右下角的纵坐标

PicName: 字符串,包含路径的图片名称,如果设置了全局路径,则可以只给出图片名称,支持多张图片,绝对路径的格式为: "路径\PicName1.bmp|路径\PicName2.bmp|路径\PicName3.bmp|……", 相对路径的格式为: "PicName1.bmp|PicName2.bmp|PicName3.bmp|……",设置了全局路径后依然可以写成绝对路径的格式,并且可以绝对路径和相对路径任意组合

ColorP: 字符串,图片每个像素颜色的偏色,BGR格式为"DBDGDR",灰度格式在灰度值前面加"G",比如"G16",HSV格式在HSV值前面加"H",比如"H210.50.2"

Sim: 双精度浮点数,颜色相似度,取值范围是[0, 1.0],表示位图像素颜色和查找区域中对应位置的像素颜色的相似度.

SimD: 双精度浮点数,点阵相似度,取值范围是(0, 1.0]. 如果图片不是透明图, 图片宽度 * 图片高度 * SimD表示找到图片所需的最小像素数量,比如一个宽和高分别为10 * 10的非透明图总共有100个像素点,而SimD设为0.9,只要在查找区域的任何一个10 * 10区域内找到90个与图片对应位置的颜色符合ColorP和Sim的像素点,函数就返回图片序号表示找到,并且返回这个10 * 10区域的左上角坐标.如果图片是透明图,用TNum表示图片中颜色不是透明色的像素个数,则 TNum * SimD表示找到图片所需的最小像素数量,比如一个宽和高分别为10 * 10的透明图总共有100个像素点,其中颜色不是透明色的像素个数为80,而SimD设为0.9,只要在查找区域的任何一个10 * 10区域内找到72个与图片对应位置的非透明颜色符合ColorP和Sim的像素点,函数就返回图片序号表示找到,并且返回这个10 * 10区域的左上角坐标.点阵相似度越低,函数越慢.

Dir: 整数,查找方向,只能是下面列出的值之一:

0: 从左到右,从上到下
1: 从左到右,从下到上
2: 从右到左,从上到下
3: 从右到左,从下到上
4: 从中心往外以顺时针螺旋方式查找,当查找区域比图片大得多时效果才明显
5: 从上到下,从左到右
6: 从上到下,从右到左
7: 从下到上,从左到右
8: 从下到上,从右到左
9: 如果你需要的结果不需要考虑查找方向,而只要在查找区域内找到就行,那建议将查找方向设置为这个值,这个值配合多线程可以更快的查找图片
Type: 整数,取值只能是0或1,0表示一定不把图片当成透明图,1表示允许把四个顶点颜色相同且像素个数大于4还至少有一个像素的颜色是非透明色的图片当成透明图

Pic: 变体指针,返回找到的图片的名称,没找到返回空

x: 变体指针,返回找到的图片左上角的横坐标,没找到返回-1

y: 变体指针,返回找到的图片左上角的纵坐标,没找到返回-1

返回值: 整数,返回第一个找到的图片的序号,图片序号按PicName中图片名从左到右的顺序从0开始进行编号,所有图片都没找到返回-1

示例:

	  AJD = AJ.FindPicD(0, 0, 1919, 1079, "C:\Pic\8.bmp", "000000", 1.0, 0.9, 0, 0, P, x, y) : TracePrint AJD & " --> " & P & " --> " & x & " , " & y
	  AJD = AJ.FindPicD(0, 0, 1919, 1079, "1.bmp|2.bmp", "101010", 0.9, 0.8, 9, 1, P, x, y) : TracePrint AJD & " --> " & P & " --> " & x & " , " & y

	  AJD = AJ.FindPicD(0, 0, 1919, 1079, L"1.bmp", L"000000", 1.0, 1.0, 0, 0, P, x, y);  SAS = P; cout << AJD << " , " << SAS << " -> " << x << " , " << y << endl;
	如果图片用函数EncryptFile加密过,在调用此函数之前需要调用函数SetPicPw设置密码图片才能加载成功

函数FindPicD与函数FindPic的内部实现方式并不一样,在有些情况下,点阵相似度为1.0的FindPicD要比FindPic快,而在另外一些情况下,FindPic要比点阵相似度为1.0的FindPicD快,这取决于图片颜色和查找区域颜色之间的关系
*/
func (com *AJsoft) FindPicD(x1, y1, x2, y2 int, PicName, ColorP string, Sim, SimD float64, Dir, Type int, Pic *string, x, y *int) int {

	nvX := ole.NewVariant(ole.VT_I4, int64(*x))
	nvY := ole.NewVariant(ole.VT_I4, int64(*y))

	nvP := ole.NewVariant(ole.VT_BSTR|ole.VT_BYREF, int64(uintptr(unsafe.Pointer(Pic))))

	ret, _ := com.aj.CallMethod("FindPicD", x1, y1, x2, y2, PicName, ColorP, Sim, SimD, Dir, Type, &nvP, &nvX, &nvY)

	*x = int(int32(nvX.Val))
	*y = int(int32(nvY.Val))

	*Pic = nvP.ToString()

	nvX.Clear()
	nvY.Clear()

	return int(int32(ret.Val))
}

/*
函数功能: 在指定的区域内查找图片,图片必须是24位位图格式,支持找透明图,当参数TypeT的值设为1,图片的四个顶点颜色相同,图片的像素个数大于4且至少有一个像素的颜色是非透明色时,把图片当成透明图,4个顶点的颜色当成透明色.如果查找的图片超过2张可以根据处理器的情况调用SetThread函数设置更多的线程并行的查找多张图片.

函数原型: 字符串 FindPicDEx(x1, y1, x2, y2, PicName, ColorP, Sim, SimD, Dir, Type, TypeT)

参数说明:
x1: 整数,区域左上角的横坐标

y1: 整数,区域左上角的纵坐标

x2: 整数,区域右下角的横坐标

y2: 整数,区域右下角的纵坐标

PicName: 字符串,包含路径的图片名称,如果设置了全局路径,则可以只给出图片名称,支持多张图片,绝对路径的格式为: "路径\PicName1.bmp|路径\PicName2.bmp|路径\PicName3.bmp|……", 相对路径的格式为: "PicName1.bmp|PicName2.bmp|PicName3.bmp|……",设置了全局路径后依然可以写成绝对路径的格式,并且可以绝对路径和相对路径任意组合

ColorP: 字符串,图片每个像素颜色的偏色,BGR格式为"DBDGDR",灰度格式在灰度值前面加"G",比如"G16",HSV格式在HSV值前面加"H",比如"H210.50.2"

Sim: 双精度浮点数,颜色相似度,取值范围是[0, 1.0],表示位图像素颜色和查找区域中对应位置的像素颜色的相似度.

SimD: 双精度浮点数,点阵相似度,取值范围是(0, 1.0]. 如果图片不是透明图, 图片宽度 * 图片高度 * SimD表示找到图片所需的最小像素数量,比如一个宽和高分别为10 * 10的非透明图总共有100个像素点,而SimD设为0.9,只要在查找区域的任何一个10 * 10区域内找到90个与图片对应位置的颜色符合ColorP和Sim的像素点,函数就返回图片序号表示找到,并且返回这个10 * 10区域的左上角坐标.如果图片是透明图,用TNum表示图片中颜色不是透明色的像素个数,则 TNum * SimD表示找到图片所需的最小像素数量,比如一个宽和高分别为10 * 10的透明图总共有100个像素点,其中颜色不是透明色的像素个数为80,而SimD设为0.9,只要在查找区域的任何一个10 * 10区域内找到72个与图片对应位置的非透明颜色符合ColorP和Sim的像素点,函数就返回图片序号表示找到,并且返回这个10 * 10区域的左上角坐标.点阵相似度越低,函数越慢.

Dir: 整数,查找方向,只能是下面列出的值之一:

0: 从左到右,从上到下
1: 从左到右,从下到上
2: 从右到左,从上到下
3: 从右到左,从下到上
4: 从中心往外以顺时针螺旋方式查找,当查找区域比图片大得多时效果才明显
5: 从上到下,从左到右
6: 从上到下,从右到左
7: 从下到上,从左到右
8: 从下到上,从右到左
9: 如果你需要的结果不需要考虑查找方向,而只要在查找区域内找到就行,那建议将查找方向设置为这个值,这样函数会选择最快的方式查找,虽然不是所有情况,但很多情况下这种查找方式比其它方式快,并且在任何情况下都不会比其它方式慢
Type: 整数,取值只能是0或1,决定透明图所有坐标的返回方式,这个参数只有要查找的图片中有透明图时才使用.0表示返回的所有坐标中任意一个坐标指示的透明图位置与其它所有坐标指示的透明图位置没有重叠的区域,1表示透明掉的区域可以重叠.比如要查找的图片中有一张宽和高为100*100的透明图片"1.bmp",在查找区域的坐标(1,1)处找到了这张透明图,那么将从查找区域中排除掉(1,1,100,100)这片区域,这时如果Type为0则透明图的任何一个像素点都不会出现在这片区域,或者说不会有下一个找到的坐标在(1,1,100,100)区域内,而如果Type为1则可以允许透明掉的像素点出现在已经找到并且排除掉的区域,或者说可能会有下一个找到的坐标在(1,1,100,100)区域内.如果图片不是透明图,则找到的所有坐标指示的位置都不会有重叠.

TypeT: 整数,取值只能是0或1,0表示一定不把图片当成透明图,1表示允许把四个顶点颜色相同且像素个数大于4还至少有一个像素的颜色是非透明色的图片当成透明图

返回值: 字符串,返回所有找到的图片的序号与名称及坐标组成的字符串,格式为"序号,名称,x,y|序号,名称,x,y|序号,名称,x,y|……",最多返回2000个坐标.图片序号按PicName中图片名从左到右的顺序从0开始进行编号,所有图片都没找到返回空

示例:
AJD = AJ.FindPicDEx(0, 0, 1919, 1079, "C:\Pic\8.bmp", "000000", 1.0, 0.9, 0, 0, 0) : TracePrint AJD
AJD = AJ.FindPicDEx(0, 0, 1919, 1079, "1.bmp|2.bmp", "101010", 0.9, 0.9, 9, 1, 1) : TracePrint AJD

如果图片用函数EncryptFile加密过,在调用此函数之前需要调用函数SetPicPw设置密码图片才能加载成功

函数FindPicDEx与函数FindPicEx的内部实现方式并不一样,在有些情况下,点阵相似度为1.0的FindPicDEx要比FindPicEx快,而在另外一些情况下,FindPicEx要比点阵相似度为1.0的FindPicDEx快,这取决于图片颜色和查找区域颜色之间的关系
*/
func (com *AJsoft) FindPicDEx(x1, y1, x2, y2 int, PicName, ColorP string, Sim, SimD float64, Dir, Type, TypeT int) string {
	ret, _ := com.aj.CallMethod("FindPicDEx", x1, y1, x2, y2, PicName, ColorP, Sim, SimD, Dir, Type, TypeT)
	return ret.ToString()
}

/*
函数功能: 在指定的区域内查找图片,图片必须是24位位图格式,支持找透明图,当参数Type的值设为1,图片的四个顶点颜色相同,图片的像素个数大于4且至少有一个像素的颜色是非透明色时,把图片当成透明图,4个顶点的颜色当成透明色.如果需要可以根据处理器的情况调用SetThread函数设置更多的线程并行的进行查找.

函数原型: 整数 FindPicDM(x1, y1, x2, y2, PicAddr, ColorP, Sim, SimD, Dir, Type, Pic, x, y)

参数说明:
x1: 整数,区域左上角的横坐标

y1: 整数,区域左上角的纵坐标

x2: 整数,区域右下角的横坐标

y2: 整数,区域右下角的纵坐标

PicAddr: 字符串,图片数据地址的集合,格式为: "地址1|地址2|地址3|……",地址都是十进制数值,所有这些地址的数据都要符合24位位图格式,即包含正确的位图文件头和位图信息头以及颜色数据

ColorP: 字符串,图片每个像素颜色的偏色,BGR格式为"DBDGDR",灰度格式在灰度值前面加"G",比如"G16",HSV格式在HSV值前面加"H",比如"H210.50.2"

Sim: 双精度浮点数,颜色相似度,取值范围是[0, 1.0],表示位图像素颜色和查找区域中对应位置的像素颜色的相似度.

SimD: 双精度浮点数,点阵相似度,取值范围是(0, 1.0]. 如果图片不是透明图, 图片宽度 * 图片高度 * SimD表示找到图片所需的最小像素数量,比如一个宽和高分别为10 * 10的非透明图总共有100个像素点,而SimD设为0.9,只要在查找区域的任何一个10 * 10区域内找到90个与图片对应位置的颜色符合ColorP和Sim的像素点,函数就返回图片序号表示找到,并且返回这个10 * 10区域的左上角坐标.如果图片是透明图,用TNum表示图片中颜色不是透明色的像素个数,则 TNum * SimD表示找到图片所需的最小像素数量,比如一个宽和高分别为10 * 10的透明图总共有100个像素点,其中颜色不是透明色的像素个数为80,而SimD设为0.9,只要在查找区域的任何一个10 * 10区域内找到72个与图片对应位置的非透明颜色符合ColorP和Sim的像素点,函数就返回图片序号表示找到,并且返回这个10 * 10区域的左上角坐标.点阵相似度越低,函数越慢.

Dir: 整数,查找方向,只能是下面列出的值之一:

0: 从左到右,从上到下
1: 从左到右,从下到上
2: 从右到左,从上到下
3: 从右到左,从下到上
4: 从中心往外以顺时针螺旋方式查找,当查找区域比图片大得多时效果才明显
5: 从上到下,从左到右
6: 从上到下,从右到左
7: 从下到上,从左到右
8: 从下到上,从右到左
9: 如果你需要的结果不需要考虑查找方向,而只要在查找区域内找到就行,那建议将查找方向设置为这个值,这个值配合多线程可以更快的查找图片
Type: 整数,取值只能是0或1,0表示一定不把图片当成透明图,1表示允许把四个顶点颜色相同且像素个数大于4还至少有一个像素的颜色是非透明色的图片当成透明图

Pic: 变体指针,返回找到的图片的地址,没找到返回空

x: 变体指针,返回找到的图片左上角的横坐标,没找到返回-1

y: 变体指针,返回找到的图片左上角的纵坐标,没找到返回-1

返回值: 整数,返回第一个找到的图片的序号,图片序号按PicAddr中图片地址从左到右的顺序从0开始进行编号,所有图片都没找到返回-1

示例:

	  LLAJD = AJ.GetScreenDataBmp(x1, y1, x2, y2, L"", Size);
	  if (LLAJD != 0) {
	    S = AJ.AddPicAddr(L"", LLAJD);
	    AJD = AJ.FindPicDM(0, 0, 1919, 1079, S, L"000000", 1.0, 1.0, 9, 0, P, x, y); SAS = P; cout << SAS << " -> " << x << " , " << y << endl;
	  }
	函数FindPicDM与函数FindPicM的内部实现方式并不一样,在有些情况下,点阵相似度为1.0的FindPicDM要比FindPicM快,而在另外一些情况下,FindPicM要比点阵相似度为1.0的FindPicDM快,这取决于图片颜色和查找区域颜色之间的关系
*/
func (com *AJsoft) FindPicDM(x1, y1, x2, y2 int, PicAddr, ColorP string, Sim, SimD float64, Dir, Type int, Pic *string, x, y *int) int {

	nvX := ole.NewVariant(ole.VT_I4, int64(*x))
	nvY := ole.NewVariant(ole.VT_I4, int64(*y))

	nvP := ole.NewVariant(ole.VT_BSTR|ole.VT_BYREF, int64(uintptr(unsafe.Pointer(Pic))))

	ret, _ := com.aj.CallMethod("FindPicDM", x1, y1, x2, y2, PicAddr, ColorP, Sim, SimD, Dir, Type, &nvP, &nvX, &nvY)

	*x = int(int32(nvX.Val))
	*y = int(int32(nvY.Val))

	*Pic = nvP.ToString()

	nvX.Clear()
	nvY.Clear()

	return int(int32(ret.Val))
}

/*
函数功能: 在指定的区域内查找图片,图片必须是24位位图格式,支持找透明图,当参数TypeT的值设为1,图片的四个顶点颜色相同,图片的像素个数大于4且至少有一个像素的颜色是非透明色时,把图片当成透明图,4个顶点的颜色当成透明色.如果查找的图片超过2张可以根据处理器的情况调用SetThread函数设置更多的线程并行的查找多张图片.

函数原型: 字符串 FindPicDMEx(x1, y1, x2, y2, PicAddr, ColorP, Sim, SimD, Dir, Type, TypeT)

参数说明:
x1: 整数,区域左上角的横坐标

y1: 整数,区域左上角的纵坐标

x2: 整数,区域右下角的横坐标

y2: 整数,区域右下角的纵坐标

PicAddr: 字符串,图片数据地址的集合,格式为: "地址1|地址2|地址3|……",地址都是十进制数值,所有这些地址的数据都要符合24位位图格式,即包含正确的位图文件头和位图信息头以及颜色数据

ColorP: 字符串,图片每个像素颜色的偏色,BGR格式为"DBDGDR",灰度格式在灰度值前面加"G",比如"G16",HSV格式在HSV值前面加"H",比如"H210.50.2"

Sim: 双精度浮点数,颜色相似度,取值范围是[0, 1.0],表示位图像素颜色和查找区域中对应位置的像素颜色的相似度.

SimD: 双精度浮点数,点阵相似度,取值范围是(0, 1.0]. 如果图片不是透明图, 图片宽度 * 图片高度 * SimD表示找到图片所需的最小像素数量,比如一个宽和高分别为10 * 10的非透明图总共有100个像素点,而SimD设为0.9,只要在查找区域的任何一个10 * 10区域内找到90个与图片对应位置的颜色符合ColorP和Sim的像素点,函数就返回图片序号表示找到,并且返回这个10 * 10区域的左上角坐标.如果图片是透明图,用TNum表示图片中颜色不是透明色的像素个数,则 TNum * SimD表示找到图片所需的最小像素数量,比如一个宽和高分别为10 * 10的透明图总共有100个像素点,其中颜色不是透明色的像素个数为80,而SimD设为0.9,只要在查找区域的任何一个10 * 10区域内找到72个与图片对应位置的非透明颜色符合ColorP和Sim的像素点,函数就返回图片序号表示找到,并且返回这个10 * 10区域的左上角坐标.点阵相似度越低,函数越慢.

Dir: 整数,查找方向,只能是下面列出的值之一:

0: 从左到右,从上到下
1: 从左到右,从下到上
2: 从右到左,从上到下
3: 从右到左,从下到上
4: 从中心往外以顺时针螺旋方式查找,当查找区域比图片大得多时效果才明显
5: 从上到下,从左到右
6: 从上到下,从右到左
7: 从下到上,从左到右
8: 从下到上,从右到左
9: 如果你需要的结果不需要考虑查找方向,而只要在查找区域内找到就行,那建议将查找方向设置为这个值,这样函数会选择最快的方式查找,虽然不是所有情况,但很多情况下这种查找方式比其它方式快,并且在任何情况下都不会比其它方式慢
Type: 整数,取值只能是0或1,决定透明图所有坐标的返回方式,这个参数只有要查找的图片中有透明图时才使用.0表示返回的所有坐标中任意一个坐标指示的透明图位置与其它所有坐标指示的透明图位置没有重叠的区域,1表示透明掉的区域可以重叠.比如要查找的图片中有一张宽和高为100*100的透明图片"1.bmp",在查找区域的坐标(1,1)处找到了这张透明图,那么将从查找区域中排除掉(1,1,100,100)这片区域,这时如果Type为0则透明图的任何一个像素点都不会出现在这片区域,或者说不会有下一个找到的坐标在(1,1,100,100)区域内,而如果Type为1则可以允许透明掉的像素点出现在已经找到并且排除掉的区域,或者说可能会有下一个找到的坐标在(1,1,100,100)区域内.如果图片不是透明图,则找到的所有坐标指示的位置都不会有重叠.

TypeT: 整数,取值只能是0或1,0表示一定不把图片当成透明图,1表示允许把四个顶点颜色相同且像素个数大于4还至少有一个像素的颜色是非透明色的图片当成透明图

返回值: 字符串,返回所有找到的图片的序号与地址及坐标组成的字符串,格式为"序号,地址,x,y|序号,地址,x,y|序号,地址,x,y|……",最多返回2000个坐标.图片序号按PicAddr中图片地址从左到右的顺序从0开始进行编号,所有图片都没找到返回空

示例:

	  LLAJD = AJ.GetScreenDataBmp(x1, y1, x2, y2, L"", Size);
	  if (LLAJD != 0) {
	    S = AJ.AddPicAddr(L"", LLAJD);
	    SA = AJ.FindPicDMEx(0, 0, 1919, 1079, S, L"000000", 1.0, 1.0, 9, 0, 0); cout << "SA: " << SA << endl;
	  }
	函数FindPicDMEx与函数FindPicMEx的内部实现方式并不一样,在有些情况下,点阵相似度为1.0的FindPicDMEx要比FindPicMEx快,而在另外一些情况下,FindPicMEx要比点阵相似度为1.0的FindPicDMEx快,这取决于图片颜色和查找区域颜色之间的关系
*/
func (com *AJsoft) FindPicDMEx(x1, y1, x2, y2 int, PicAddr, ColorP string, Sim, SimD float64, Dir, Type, TypeT int) string {
	ret, _ := com.aj.CallMethod("FindPicDMEx", x1, y1, x2, y2, PicAddr, ColorP, Sim, SimD, Dir, Type, TypeT)
	return ret.ToString()
}

/*
函数功能: 在指定的区域内查找图片,图片必须是24位位图格式,支持找透明图,当参数TypeT的值设为1,图片的四个顶点颜色相同,图片的像素个数大于4且至少有一个像素的颜色是非透明色时,把图片当成透明图,4个顶点的颜色当成透明色.如果查找的图片超过2张可以根据处理器的情况调用SetThread函数设置更多的线程并行的查找多张图片.

函数原型: 字符串 FindPicEx(x1, y1, x2, y2, PicName, ColorP, Sim, Dir, Type, TypeT)

参数说明:
x1: 整数,区域左上角的横坐标

y1: 整数,区域左上角的纵坐标

x2: 整数,区域右下角的横坐标

y2: 整数,区域右下角的纵坐标

PicName: 字符串,包含路径的图片名称,如果设置了全局路径,则可以只给出图片名称,支持多张图片,绝对路径的格式为: "路径\PicName1.bmp|路径\PicName2.bmp|路径\PicName3.bmp|……", 相对路径的格式为: "PicName1.bmp|PicName2.bmp|PicName3.bmp|……",设置了全局路径后依然可以写成绝对路径的格式,并且可以绝对路径和相对路径任意组合

ColorP: 字符串,图片每个像素颜色的偏色,BGR格式为"DBDGDR",灰度格式在灰度值前面加"G",比如"G16",HSV格式在HSV值前面加"H",比如"H210.50.2"

Sim: 双精度浮点数,颜色相似度,取值范围是[0, 1.0],这个是位图像素颜色和查找区域中对应位置的像素颜色的相似度,不是点阵相似度,这个函数的点阵相似度默认为1.0

Dir: 整数,查找方向,只能是下面列出的值之一:

0: 从左到右,从上到下
1: 从左到右,从下到上
2: 从右到左,从上到下
3: 从右到左,从下到上
4: 从中心往外以顺时针螺旋方式查找,当查找区域比图片大得多时效果才明显
5: 从上到下,从左到右
6: 从上到下,从右到左
7: 从下到上,从左到右
8: 从下到上,从右到左
9: 如果你需要的结果不需要考虑查找方向,而只要在查找区域内找到就行,那建议将查找方向设置为这个值,这样函数会选择最快的方式查找,虽然不是所有情况,但很多情况下这种查找方式比其它方式快,并且在任何情况下都不会比其它方式慢
Type: 整数,取值只能是0或1,决定透明图所有坐标的返回方式,这个参数只有要查找的图片中有透明图时才使用.0表示返回的所有坐标中任意一个坐标指示的透明图位置与其它所有坐标指示的透明图位置没有重叠的区域,1表示透明掉的区域可以重叠.比如要查找的图片中有一张宽和高为100*100的透明图片"1.bmp",在查找区域的坐标(1,1)处找到了这张透明图,那么将从查找区域中排除掉(1,1,100,100)这片区域,这时如果Type为0则透明图的任何一个像素点都不会出现在这片区域,或者说不会有下一个找到的坐标在(1,1,100,100)区域内,而如果Type为1则可以允许透明掉的像素点出现在已经找到并且排除掉的区域,或者说可能会有下一个找到的坐标在(1,1,100,100)区域内.如果图片不是透明图,则找到的所有坐标指示的位置都不会有重叠.

TypeT: 整数,取值只能是0或1,0表示一定不把图片当成透明图,1表示允许把四个顶点颜色相同且像素个数大于4还至少有一个像素的颜色是非透明色的图片当成透明图

返回值: 字符串,返回所有找到的图片的序号与名称及坐标组成的字符串,格式为"序号,名称,x,y|序号,名称,x,y|序号,名称,x,y|……",最多返回2000个坐标.图片序号按PicName中图片名从左到右的顺序从0开始进行编号,所有图片都没找到返回空

示例:
AJD = AJ.FindPicEx(0, 0, 1919, 1079, "C:\Pic\8.bmp", "000000", 1.0, 0, 0, 0) : TracePrint AJD
AJD = AJ.FindPicEx(0, 0, 1919, 1079, "1.bmp|2.bmp", "101010", 0.9, 9, 1, 1) : TracePrint AJD

如果图片用函数EncryptFile加密过,在调用此函数之前需要调用函数SetPicPw设置密码图片才能加载成功
*/
func (com *AJsoft) FindPicEx(x1, y1, x2, y2 int, PicName, ColorP string, Sim float64, Dir, Type, TypeT int) string {
	ret, _ := com.aj.CallMethod("FindPicEx", x1, y1, x2, y2, PicName, ColorP, Sim, Dir, Type, TypeT)
	return ret.ToString()
}

/*
函数功能: 在指定的区域内查找图片,图片必须是24位位图格式,支持找透明图,当参数Type的值设为1,图片的四个顶点颜色相同,图片的像素个数大于4且至少有一个像素的颜色是非透明色时,把图片当成透明图,4个顶点的颜色当成透明色.如果查找的图片超过2张可以根据处理器的情况调用SetThread函数设置更多的线程并行的查找多张图片.

函数原型: 整数 FindPicM(x1, y1, x2, y2, PicAddr, ColorP, Sim, Dir, Type, Pic, x, y)

参数说明:
x1: 整数,区域左上角的横坐标

y1: 整数,区域左上角的纵坐标

x2: 整数,区域右下角的横坐标

y2: 整数,区域右下角的纵坐标

PicAddr: 字符串,图片数据地址的集合,格式为: "地址1|地址2|地址3|……",地址都是十进制数值,所有这些地址的数据都要符合24位位图格式,即包含正确的位图文件头和位图信息头以及颜色数据

ColorP: 字符串,图片每个像素颜色的偏色,BGR格式为"DBDGDR",灰度格式在灰度值前面加"G",比如"G16",HSV格式在HSV值前面加"H",比如"H210.50.2"

Sim: 双精度浮点数,颜色相似度,取值范围是[0, 1.0],这个是位图像素颜色和查找区域中对应位置的像素颜色的相似度,不是点阵相似度,这个函数的点阵相似度默认为1.0

Dir: 整数,查找方向,只能是下面列出的值之一:

0: 从左到右,从上到下
1: 从左到右,从下到上
2: 从右到左,从上到下
3: 从右到左,从下到上
4: 从中心往外以顺时针螺旋方式查找,当查找区域比图片大得多时效果才明显
5: 从上到下,从左到右
6: 从上到下,从右到左
7: 从下到上,从左到右
8: 从下到上,从右到左
9: 如果你需要的结果不需要考虑查找方向,而只要在查找区域内找到就行,那建议将查找方向设置为这个值,这样函数会选择最快的方式查找,虽然不是所有情况,但很多情况下这种查找方式比其它方式快,并且在任何情况下都不会比其它方式慢
Type: 整数,取值只能是0或1,0表示一定不把图片当成透明图,1表示允许把四个顶点颜色相同且像素个数大于4还至少有一个像素的颜色是非透明色的图片当成透明图

Pic: 变体指针,返回找到的图片的地址,没找到返回空

x: 变体指针,返回找到的图片左上角的横坐标,没找到返回-1

y: 变体指针,返回找到的图片左上角的纵坐标,没找到返回-1

返回值: 整数,返回第一个找到的图片的序号,图片序号按PicAddr中图片地址从左到右的顺序从0开始进行编号,所有图片都没找到返回-1

示例:

	LLAJD = AJ.GetScreenDataBmp(x1, y1, x2, y2, L"", Size);
	if (LLAJD != 0) {
	  S = AJ.AddPicAddr(L"", LLAJD);
	  AJD = AJ.FindPicM(0, 0, 1919, 1079, S, L"000000", 1.0, 9, 0, P, x, y); SAS = P; cout << SAS << " -> " << x << " , " << y << endl;
	}
*/
func (com *AJsoft) FindPicM(x1, y1, x2, y2 int, PicAddr, ColorP string, Sim float64, Dir, Type int, Pic *string, x, y *int) int {

	nvX := ole.NewVariant(ole.VT_I4, int64(*x))
	nvY := ole.NewVariant(ole.VT_I4, int64(*y))

	nvP := ole.NewVariant(ole.VT_BSTR|ole.VT_BYREF, int64(uintptr(unsafe.Pointer(Pic))))

	ret, _ := com.aj.CallMethod("FindPicM", x1, y1, x2, y2, PicAddr, ColorP, Sim, Dir, Type, &nvP, &nvX, &nvY)

	*x = int(int32(nvX.Val))
	*y = int(int32(nvY.Val))

	*Pic = nvP.ToString()

	nvX.Clear()
	nvY.Clear()

	return int(int32(ret.Val))
}

/*
函数功能: 在指定的区域内查找图片,图片必须是24位位图格式,支持找透明图,当参数TypeT的值设为1,图片的四个顶点颜色相同,图片的像素个数大于4且至少有一个像素的颜色是非透明色时,把图片当成透明图,4个顶点的颜色当成透明色.如果查找的图片超过2张可以根据处理器的情况调用SetThread函数设置更多的线程并行的查找多张图片.

函数原型: 字符串 FindPicMEx(x1, y1, x2, y2, PicAddr, ColorP, Sim, Dir, Type, TypeT)

参数说明:
x1: 整数,区域左上角的横坐标

y1: 整数,区域左上角的纵坐标

x2: 整数,区域右下角的横坐标

y2: 整数,区域右下角的纵坐标

PicAddr: 字符串,图片数据地址的集合,格式为: "地址1|地址2|地址3|……",地址都是十进制数值,所有这些地址的数据都要符合24位位图格式,即包含正确的位图文件头和位图信息头以及颜色数据

ColorP: 字符串,图片每个像素颜色的偏色,BGR格式为"DBDGDR",灰度格式在灰度值前面加"G",比如"G16",HSV格式在HSV值前面加"H",比如"H210.50.2"

Sim: 双精度浮点数,颜色相似度,取值范围是[0, 1.0],这个是位图像素颜色和查找区域中对应位置的像素颜色的相似度,不是点阵相似度,这个函数的点阵相似度默认为1.0

Dir: 整数,查找方向,只能是下面列出的值之一:

0: 从左到右,从上到下
1: 从左到右,从下到上
2: 从右到左,从上到下
3: 从右到左,从下到上
4: 从中心往外以顺时针螺旋方式查找,当查找区域比图片大得多时效果才明显
5: 从上到下,从左到右
6: 从上到下,从右到左
7: 从下到上,从左到右
8: 从下到上,从右到左
9: 如果你需要的结果不需要考虑查找方向,而只要在查找区域内找到就行,那建议将查找方向设置为这个值,这样函数会选择最快的方式查找,虽然不是所有情况,但很多情况下这种查找方式比其它方式快,并且在任何情况下都不会比其它方式慢
Type: 整数,取值只能是0或1,决定透明图所有坐标的返回方式,这个参数只有要查找的图片中有透明图时才使用.0表示返回的所有坐标中任意一个坐标指示的透明图位置与其它所有坐标指示的透明图位置没有重叠的区域,1表示透明掉的区域可以重叠.比如要查找的图片中有一张宽和高为100*100的透明图片"1.bmp",在查找区域的坐标(1,1)处找到了这张透明图,那么将从查找区域中排除掉(1,1,100,100)这片区域,这时如果Type为0则透明图的任何一个像素点都不会出现在这片区域,或者说不会有下一个找到的坐标在(1,1,100,100)区域内,而如果Type为1则可以允许透明掉的像素点出现在已经找到并且排除掉的区域,或者说可能会有下一个找到的坐标在(1,1,100,100)区域内.如果图片不是透明图,则找到的所有坐标指示的位置都不会有重叠.

TypeT: 整数,取值只能是0或1,0表示一定不把图片当成透明图,1表示允许把四个顶点颜色相同且像素个数大于4还至少有一个像素的颜色是非透明色的图片当成透明图

返回值: 字符串,返回所有找到的图片的序号与地址及坐标组成的字符串,格式为"序号,地址,x,y|序号,地址,x,y|序号,地址,x,y|……",最多返回2000个坐标.图片序号按PicAddr中图片地址从左到右的顺序从0开始进行编号,所有图片都没找到返回空

示例:

	LLAJD = AJ.GetScreenDataBmp(x1, y1, x2, y2, L"", Size);
	if (LLAJD != 0) {
	  S = AJ.AddPicAddr(L"", LLAJD);
	  SA = AJ.FindPicMEx(0, 0, 1919, 1079, S, L"000000", 1.0, 9, 0, 0); cout << "SA: " << SA << endl;
	}
*/
func (com *AJsoft) FindPicMEx(x1, y1, x2, y2 int, PicAddr, ColorP string, Sim float64, Dir, Type, TypeT int) string {
	ret, _ := com.aj.CallMethod("FindPicMEx", x1, y1, x2, y2, PicAddr, ColorP, Sim, Dir, Type, TypeT)
	return ret.ToString()
}

/*
函数功能: 在指定的区域内查找形状

函数原型: 整数 FindShape(x1, y1, x2, y2, ColorP, Dir, SimP, SimD, x, y)

参数说明:
x1: 整数,区域左上角的横坐标

y1: 整数,区域左上角的纵坐标

x2: 整数,区域右下角的横坐标

y2: 整数,区域右下角的纵坐标

ColorP: 字符串,所有偏移点的坐标和描述,格式和按键精灵的区域多点找形状相同,格式为"x1|y1|(1或0),x2|y2|(1或0),x3|y3|(1或0),……,xn|yn|(1或0)".这个函数和多点找色类似,不同在于这个函数没有指定第一个点和各偏移点的颜色,并且偏移点的颜色与第一个点的颜色只有是第一个点的颜色或不是第一个点的颜色的关系,由坐标后面的1和0描述这种关系,1表示要求这个偏移点的颜色要和第一个点的颜色相同,0表示要求这个偏移点的颜色要和第一个点的颜色不同,而第一个点可以是任何颜色,函数会试着把查找区域的每一个点当成是第一个点,并把这个点的颜色当成是第一个点的颜色去进行匹配.

Dir: 整数,第一个点的查找方向,函数用这个查找方向查找第一个点的坐标,只能是下面列出的值之一:

0: 从左到右,从上到下
1: 从左到右,从下到上
2: 从右到左,从上到下
3: 从右到左,从下到上
4: 从中心往外以顺时针螺旋方式查找
5: 从上到下,从左到右
6: 从上到下,从右到左
7: 从下到上,从左到右
8: 从下到上,从右到左
9: 如果你需要的结果不需要考虑查找方向,而只要在查找区域内找到就行,那建议将查找方向设置为这个值,这样函数会选择最快的方式查找,虽然不是所有情况,但很多情况下这种查找方式比其它方式快,并且在任何情况下都不会比其它方式慢
SimP: 双精度浮点数,所有偏移点的颜色相似度,取值范围是[0, 1.0],函数用这个相似度比对所有偏移点的颜色是否匹配,当相似度不为1.0时,表示偏移点的颜色数值可以和第一个点的颜色数值不相等,而只要满足相似度就能匹配成功.

SimD: 双精度浮点数,取值范围是(0, 1.0].用NumP表示ColorP中所有偏移点的数量,则NumP * SimD表示函数比对偏移点成功所需的最小数量. 比如ColorP中有10个偏移点,而将SimD设为0.9,表示所有偏移点中只要有任意9个偏移点比对成功函数就能成功返回.

x: 变体指针,返回找到的形状的第一个点的横坐标,没找到返回-1

y: 变体指针,返回找到的形状的第一个点的纵坐标,没找到返回-1

返回值: 整数,返回1表示找到,0表示没找到

示例:
AJD = AJ.FindShape(0, 0, 1919, 1079, "1|1|0,1|6|1,0|10|1,9|10|1,7|6|1,7|8|0,8|9|0,2|2|1,3|1|1", 0, 0.9, 1.0, x, y) : TracePrint AJD & " --> " & x & " , " & y
AJD = AJ.FindShape(0, 0, 1919, 1079, "-1|0|1,-1|-1|1,1|0|1,1|-1|1,1|0|1,1|1|1,1|2|1,-2|3|1,-3|4|1,2|4|1,1|3|1,3|-1|1", 9, 0.9, 0.9, x, y) : TracePrint AJD & " --> " & x & " , " & y
*/
func (com *AJsoft) FindShape(x1, y1, x2, y2 int, ColorP string, Dir int, SimP, SimD float64, x, y *int) int {

	nvX := ole.NewVariant(ole.VT_I4, int64(*x))
	nvY := ole.NewVariant(ole.VT_I4, int64(*y))

	ret, _ := com.aj.CallMethod("FindShape", x1, y1, x2, y2, ColorP, Dir, SimP, SimD, &nvX, &nvY)

	*x = int(int32(nvX.Val))
	*y = int(int32(nvY.Val))

	nvX.Clear()
	nvY.Clear()

	return int(ret.Val)
}

/*
函数功能: 在指定的区域内查找形状

函数原型: 字符串 FindShapeEx(x1, y1, x2, y2, ColorP, Dir, SimP, SimD)

参数说明:
x1: 整数,区域左上角的横坐标

y1: 整数,区域左上角的纵坐标

x2: 整数,区域右下角的横坐标

y2: 整数,区域右下角的纵坐标

ColorP: 字符串,所有偏移点的坐标和描述,格式和按键精灵的区域多点找形状相同,格式为"x1|y1|(1或0),x2|y2|(1或0),x3|y3|(1或0),……,xn|yn|(1或0)".这个函数和多点找色类似,不同在于这个函数没有指定第一个点和各偏移点的颜色,并且偏移点的颜色与第一个点的颜色只有是第一个点的颜色或不是第一个点的颜色的关系,由坐标后面的1和0描述这种关系,1表示要求这个偏移点的颜色要和第一个点的颜色相同,0表示要求这个偏移点的颜色要和第一个点的颜色不同,而第一个点可以是任何颜色,函数会试着把查找区域的每一个点当成是第一个点,并把这个点的颜色当成是第一个点的颜色去进行匹配.

Dir: 整数,第一个点的查找方向,函数用这个查找方向查找第一个点的坐标,只能是下面列出的值之一:

0: 从左到右,从上到下
1: 从左到右,从下到上
2: 从右到左,从上到下
3: 从右到左,从下到上
4: 从中心往外以顺时针螺旋方式查找
5: 从上到下,从左到右
6: 从上到下,从右到左
7: 从下到上,从左到右
8: 从下到上,从右到左
9: 如果你需要的结果不需要考虑查找方向,而只要在查找区域内找到就行,那建议将查找方向设置为这个值,这样函数会选择最快的方式查找,虽然不是所有情况,但很多情况下这种查找方式比其它方式快,并且在任何情况下都不会比其它方式慢
SimP: 双精度浮点数,所有偏移点的颜色相似度,取值范围是[0, 1.0],函数用这个相似度比对所有偏移点的颜色是否匹配,当相似度不为1.0时,表示偏移点的颜色数值可以和第一个点的颜色数值不相等,而只要满足相似度就能匹配成功.

SimD: 双精度浮点数,取值范围是(0, 1.0].用NumP表示ColorP中所有偏移点的数量,则NumP * SimD表示函数比对偏移点成功所需的最小数量. 比如ColorP中有10个偏移点,而将SimD设为0.9,表示所有偏移点中只要有任意9个偏移点比对成功函数就能成功返回.

返回值: 字符串,返回所有找到的形状的第一个点的坐标,格式为"x,y|x,y|x,y|……",一个形状都没找到返回空.当查找方向的值为9时函数最多返回2001个坐标,查找方向的值不为9时最多返回3999个坐标.

示例:
AJD = AJ.FindShapeEx(0, 0, 1919, 1079, "1|1|0,1|6|1,0|10|1,9|10|1,7|6|1,7|8|0,8|9|0,2|2|1,3|1|1", 0, 0.9, 1.0) : TracePrint AJD
AJD = AJ.FindShapeEx(0, 0, 1919, 1079, "-1|0|1,-1|-1|1,1|0|1,1|-1|1,1|0|1,1|1|1,1|2|1,-2|3|1,-3|4|1,2|4|1,1|3|1,3|-1|1", 9, 0.9, 0.9) : TracePrint AJD
*/
func (com *AJsoft) FindShapeEx(x1, y1, x2, y2 int, ColorP string, Dir int, SimP, SimD float64) string {
	ret, _ := com.aj.CallMethod("FindShapeEx", x1, y1, x2, y2, ColorP, Dir, SimP, SimD)
	return ret.ToString()
}

/*
函数功能: 从缓存中释放指定的图片,除非内存不够用或要重新加载图片,否则此函数根本不必要调用

函数原型: 整数 FreePic(PicName)

参数说明:
PicName: 字符串,包含路径的图片名称,如果设置了全局路径,则可以只给出图片名称,支持多个图片,绝对路径的格式为: "路径\PicName1.bmp|路径\PicName2.bmp|路径\PicName3.bmp|……", 相对路径的格式为: "PicName1.bmp|PicName2.bmp|PicName3.bmp|……",设置了全局路径后依然可以写成绝对路径的格式,并且可以绝对路径和相对路径任意组合.图片名中可以使用符号"*"和"?",示例说明如下:

"*.bmp" : 表示释放全局路径下所有已加载到缓存中的bmp文件,如果没有设置全局路径则要给出完整的路径
"1?2.bmp": 表示释放全局路径下所有已加载到缓存中的第一个字符是1,第二个字符任意,第三个字符是2的bmp文件
"d*.bmp": 表示释放全局路径下所有已加载到缓存中的以d字符开头的bmp文件
"1?23?4*.bmp": 表示释放全局路径下所有已加载到缓存中的以字符串1?23?4开头并且第一个字符是1,第二个字符任意,第三个字符是2,第四个字符是3,第5个字符任意,第六个字符是4的bmp文件
这个参数可以是相对路径或绝对路径,含有或不含有符号"*"和"?"这样任意的组合,还可以设置为空,表示释放缓存中所有的图片.要释放从其它路径加载的图片应该包含完整的路径

返回值: 整数,成功返回1,失败返回0

示例:
AJD = AJ.FreePic("1?2.bmp|C:\Pic\1.bmp|d*.bmp")
AJD = AJ.FreePic("C:\Pic\*.bmp")
AJD = AJ.FreePic("")
*/
func (com *AJsoft) FreePic(PicName string) int {
	ret, _ := com.aj.CallMethod("FreePic", PicName)
	return int(ret.Val)
}

/*
函数功能: 获取坐标为(x,y)的像素点的颜色,返回值的类型由参数Type指定,可以是整数或BGR,RGB,HSV颜色格式的字符串

函数原型: 变体型 GetColor(x, y, Type, TypeD)

参数说明:
x: 整数,像素点的横坐标

y: 整数,像素点的纵坐标

Type: 整数,指定返回值的类型,只能是以下值之一:

0: 返回16进制数0xBBGGRR对应的十进制整数所表示的颜色值,值的范围是[0, 16777215]
1: 返回BGR颜色格式的字符串所表示的颜色值
2: 返回RGB颜色格式的字符串所表示的颜色值
3: 返回HSV颜色格式的字符串所表示的颜色值
Type: 整数,取值只能是0或1,0表示不用截图的方式获取颜色,1表示使用截图的方式获取颜色,Type为0只能获取桌面或后台窗口像素的颜色,Type为1还可以获取用SetPCData设置的图片的像素的颜色.

返回值: 变体型,返回用整数或BGR,RGB,HSV颜色格式的字符串所表示的颜色值,BGR或RGB颜色格式的字母为小写,如果参数不正确返回-1.

示例:
AJD = AJ.GetColor(100, 100 , 0, 0) : TracePrint AJD
AJD = AJ.GetColor(666, 666, 1, 1) : TracePrint AJD
AJD = AJ.GetColor(100, 100 , 2, 0) : TracePrint AJD
AJD = AJ.GetColor(666, 666, 3, 1) : TracePrint AJD
*/
func (com *AJsoft) GetColor(x, y, Type, TypeD int) int {
	ret, _ := com.aj.CallMethod("GetColor", x, y, Type, TypeD)
	return int(int32(ret.Val))
}

/*
函数功能: 获取指定范围内所有颜色的平均值,返回值的类型由参数Type指定,可以是整数或BGR,RGB,HSV颜色格式的字符串

函数原型: 变体型 GetColorAve(x1, y1, x2, y2, Type)

参数说明:
x1: 整数,区域左上角的横坐标

y1: 整数,区域左上角的纵坐标

x2: 整数,区域右下角的横坐标

y2: 整数,区域右下角的纵坐标

Type: 整数,指定返回值的类型,只能是以下值之一:

0: 返回16进制数0xBBGGRR对应的十进制整数所表示的颜色平均值,值的范围是[0, 16777215]
1: 返回BGR颜色格式的字符串所表示的颜色平均值
2: 返回RGB颜色格式的字符串所表示的颜色平均值
3: 返回HSV颜色格式的字符串所表示的颜色平均值
返回值: 变体型,返回用整数或BGR,RGB,HSV颜色格式的字符串所表示的颜色平均值,BGR或RGB颜色格式的字母为小写.所有颜色的数量包含边界,也就是说,如果x1, y1, x2, y2都在桌面分辨率范围内,所有颜色的数量是(x2 - x1 + 1) * (y2 - y1 + 1)而不是(x2 - x1) * (y2 - y1)

示例:
AJD = AJ.GetColorAve(1348, 300, 1448, 400, 0) : TracePrint AJD
AJD = AJ.GetColorAve(111, 222, 333, 444, 1) : TracePrint AJD
AJD = AJ.GetColorAve(0, 0, 1919, 1079, 2) : TracePrint AJD
AJD = AJ.GetColorAve(666, 666, 999, 999, 3) : TracePrint AJD
*/
func (com *AJsoft) GetColorAve(x1, y1, x2, y2, Type int) int {
	ret, _ := com.aj.CallMethod("GetColorAve", x1, y1, x2, y2, Type)
	return int(int32(ret.Val))
}

/*
函数功能: 获取指定区域内某种或某些颜色的数量

函数原型: 整数 GetColorNum(x1, y1, x2, y2, Color, Sim)

参数说明:
x1: 整数,区域左上角的横坐标

y1: 整数,区域左上角的纵坐标

x2: 整数,区域右下角的横坐标

y2: 整数,区域右下角的纵坐标

Color: 字符串,要获取数量的颜色,支持偏色,多色,格式为"BBGGRR-DBDGDR|BBGGRR-DBDGDR|BBGGRR-DBDGDR|……",颜色数量不限

Sim: 双精度浮点数,颜色相似度,取值范围是[0, 1.0]

返回值: 整数,返回在指定区域内获取到的颜色数量,这个数量包含边界,也就是说,如果x1, y1, x2, y2都在桌面分辨率范围内,能获取到的数量的最大值是(x2 - x1 + 1) * (y2 - y1 + 1)而不是(x2 - x1) * (y2 - y1),极限最大值是桌面的横向分辨率乘以纵向分辨率的数值

示例:
AJD = AJ.GetColorNum(0, 0, 1919, 1079, "808080-808080", 1.0) : TracePrint AJD
AJD = AJ.GetColorNum(100, 100, 1000, 1000, "123456-123456|666666-101010|FFFFFF-000000", 0.93) : TracePrint AJD
*/
func (com *AJsoft) GetColorNum(x1, y1, x2, y2 int, Color string, Sim float64) int {
	ret, _ := com.aj.CallMethod("GetColorNum", x1, y1, x2, y2, Color, Sim)
	return int(ret.Val)
}

/*
函数功能: 获取某张图片的宽度和高度,如果开启了图片缓存机制,会把这张图片加入缓存

函数原型: 整数 GetPicSize(PicName, PicW, PicH)

参数说明:
PicName: 字符串,包含路径的图片名称,如果设置了全局路径,则可以只给出图片名称,只能是一张图片.

PicW: 变体指针,返回图片的宽度,参数不正确返回-1

PicH: 变体指针,返回图片的高度,参数不正确返回-1

返回值: 整数,返回1表示成功,0表示失败

示例:
AJD = AJ.GetPicSize("C:\Pic\8.bmp", PicW, PicH) : TracePrint AJD & " --> " & PicW & " , " & PicH
AJD = AJ.GetPicSize("1.bmp", PicW, PicH) : TracePrint AJD & " --> " & PicW & " , " & PicH

如果图片用函数EncryptFile加密过,在调用此函数之前需要调用函数SetPicPw设置密码才能获取成功
*/
func (com *AJsoft) GetPicSize(PicName string, PicW, PicH *int) int {

	nvPW := ole.NewVariant(ole.VT_I4, int64(*PicW))
	nvPH := ole.NewVariant(ole.VT_I4, int64(*PicH))

	ret, _ := com.aj.CallMethod("GetPicSize", PicName, &nvPW, &nvPH)

	*PicW = int(int32(nvPW.Val))
	*PicH = int(int32(nvPH.Val))

	return int(ret.Val)
}

/*
函数功能: 获取指定区域的颜色数据

函数原型: 64位长整数 GetScreenData(x1, y1, x2, y2)

参数说明:
x1: 整数,区域左上角的横坐标

y1: 整数,区域左上角的纵坐标

x2: 整数,区域右下角的横坐标

y2: 整数,区域右下角的纵坐标

返回值: 64位长整数,返回获取到的颜色数据的地址,失败返回0

示例:

	  //每个像素的颜色数据占3个字节,格式是BBGGRR.每行的颜色数据都是4字节对齐,ij是每行颜色数据的字节数
	  //每行颜色数据是自下而上的,也就是指定区域最上面那行像素的颜色数据在这个数据地址的最后面
	  //jj是指定区域颜色数据的总字节数,也是返回的这个数据地址的长度
	  LONGLONG pLLAJD = AJ.GetScreenData(x1, y1, x2, y2);
	  if (pLLAJD != 0) {
	    int i, j, ii, jj, ij, iid, b, g, r; CStringA SA;
	    ii = (x2 - x1 + 1) * 3; iid = ii % 4;
	    if (iid == 0) {
	      ij = ii;
	    }
	    else {
	      ij = ii + 4 - iid;
	    }
	    jj = ij * (y2 - y1 + 1); cout << "数据地址的长度: " << jj << endl;
	    for (j = jj - ij; j >= 0; j -= ij) {
	      for (i = 0; i < ii; i += 3) {
	        b = ((BYTE*)pLLAJD)[j + i]; g = ((BYTE*)pLLAJD)[j + i + 1]; r = ((BYTE*)pLLAJD)[j + i + 2];
	        SA.Format("第%d行第%d个像素: 蓝色值:%d  绿色值:%d  红色值:%d", (jj - j) / ij, (i + 3) / 3, b, g, r); cout << SA << endl;
	      }
	    }
	  }
	函数会在当前进程开辟一个内存空间存放获取到的颜色数据,这个内存空间会被这个函数重复使用,如果已经开辟的内存空间的大小小于后面调用这个函数时所需的大小,会释放已经开辟的内存空间然后重新开辟新的内存空间,所以这个地址的数据应该在下次调用这个函数之前使用,当前对象释放时会自动释放这块内存空间
*/
func (com *AJsoft) GetScreenData(x1, y1, x2, y2 int) int64 {
	ret, _ := com.aj.CallMethod("GetScreenData", x1, y1, x2, y2)
	return ret.Val
}

/*
函数功能: 获取指定区域的图像数据,并用24位位图的格式返回

函数原型: 64位长整数 GetScreenDataBmp(x1, y1, x2, y2, PicName, Size)

参数说明:
x1: 整数,区域左上角的横坐标

y1: 整数,区域左上角的纵坐标

x2: 整数,区域右下角的横坐标

y2: 整数,区域右下角的纵坐标

PicName: 字符串,要保存的包含路径的图片名,保存格式为24位位图,如果设置了全局路径,则可以只给出图片名称,只能是一张图片.如果不需要保存获取到的图像数据设为空

Size: 变体指针,返回获取到的图像数据的长度,失败返回0

返回值: 64位长整数,返回获取到的图像数据的地址,失败返回0

示例:

	  LLAJD = AJ.GetScreenDataBmp(x1, y1, x2, y2, L"", Size);
	  if (LLAJD != 0) {
	    S = AJ.AddPicAddr(L"", LLAJD);
	    AJD = AJ.FindPicM(0, 0, 1919, 1079, S, L"000000", 1.0, 9, 0, P, x, y); SAS = P; cout << SAS << " -> " << x << " , " << y << endl;
	  }

	  LLAJD = AJ.GetScreenDataBmp(x1, y1, x2, y2, L"C:\\Users\\Administrator\\Desktop\\1.bmp", Size);
	  if (LLAJD != 0) {
	    AJD = AJ.LoadPicM(LLAJD, L"LLAJD.bmp");
	    AJD = AJ.FindPicD(0, 0, 1919, 1079, L"LLAJD.bmp", L"000000", 1.0, 1.0, 9, 0, P, x, y); SAS = P; cout << SAS << " -> " << x << " , " << y << endl;
	  }
	这个函数返回的图像数据和GetScreenData返回的颜色数据相比,在颜色数据前多了位图文件头和位图信息头的数据,其中包含的颜色数据的格式和GetScreenData返回的完全一样

函数会在当前进程开辟一个内存空间存放获取到的图像数据,这个内存空间会被这个函数重复使用,如果已经开辟的内存空间的大小小于后面调用这个函数时所需的大小,会释放已经开辟的内存空间然后重新开辟新的内存空间,所以这个地址的数据应该在下次调用这个函数之前使用,当前对象释放时会自动释放这块内存空间

如果需要将获取到的图像数据加载到图片缓存,可以调用函数LoadPicM并将这个函数返回的地址传递给LoadPicM
*/
func (com *AJsoft) GetScreenDataBmp(x1, y1, x2, y2 int, PicName string) (int64, int64) {
	size := ole.NewVariant(ole.VT_I4, int64(0))

	ret, _ := com.aj.CallMethod("GetScreenDataBmp", x1, y1, x2, y2, PicName, &size)

	size.Clear()
	return ret.Val, size.Val
}

func (com *AJsoft) GetScreenDataBmpBytes(x1, y1, x2, y2 int, PicName string) []byte {

	data, size := com.GetScreenDataBmp(x1, y1, x2, y2, PicName)
	return *(*[]byte)(unsafe.Pointer(&_bytes{
		Data: int(data),
		Len:  int(size),
	}))
}

/*
函数功能: 将HSV的颜色格式转换为BGR或RGB的颜色格式

函数原型: 字符串 HSVtoBGRorRGB(Color, Type)

参数说明:
Color: 字符串,HSV颜色格式的字符串.H是色调,取值范围是[0, 360],S是饱和度,取值范围是[0%, 100%],V是明度,取值范围是[0%, 100%].HSV颜色格式的字符串可以看成是将H的值和S与V的百分比的分子用"."连接而成,如H为30,S为79%,V为34%,HSV颜色格式的字符串是: 30.79.34

Type: 整数,指定返回的字符串是BGR颜色格式还是RGB颜色格式,取值只能是0或1,为0表示返回BGR颜色格式的字符串,为1表示返回RGB颜色格式的字符串

返回值: 字符串,返回BGR或RGB颜色格式的字符串

示例:

	  AJD = AJ.HSVtoBGRorRGB("30.79.34", 0) : TracePrint AJD
	  AJD = AJ.HSVtoBGRorRGB("30.79.34", 1) : TracePrint AJD
	插件所支持的HSV的值空间的值数量是: 361*101*101=3682561, 而BGR或RGB的值空间的值数量是: 256*256*256=16777216,也就是说所有可能的HSV值只有3682561个,而所有可能的BGR或RGB值却有16777216个,因为HSV的值空间没有BGR或RGB的值空间大,所以一个HSV值无法唯一对应一个BGR或RGB值,在某个小范围内的多个BGR或RGB值会转换成相同的HSV值,将BGR或RGB值转换成HSV值会是准确的,但是当从HSV值转换回BGR或RGB值时,会转换成多个BGR或RGB值中的某个(也许不是原来那个)
*/
func (com *AJsoft) HSVtoBGRorRGB(Color string, Type int) string {
	ret, _ := com.aj.CallMethod("HSVtoBGRorRGB", Color, Type)
	return ret.ToString()
}

/*
函数功能: 在指定区域和指定时间内通过不停截图比对图色数据判断桌面或后台窗口是否卡屏

函数原型: 整数 IsScreenStuck(x1, y1, x2, y2, T)

参数说明:
x1: 整数,区域左上角的横坐标

y1: 整数,区域左上角的纵坐标

x2: 整数,区域右下角的横坐标

y2: 整数,区域右下角的纵坐标

T: 整数,判断时间,单位是毫秒,只能是大于0的整数

返回值: 整数,返回1表示卡屏,0表示没有卡屏,参数不正确或判断失败返回-1

示例:
AJD = AJ.IsScreenStuck(0, 0, 200, 200, 2000) : TracePrint AJD
AJD = AJ.IsScreenStuck(666, 666, 999, 999, 1000) : TracePrint AJD
*/
func (com *AJsoft) IsScreenStuck(x1, y1, x2, y2, T int) int {
	ret, _ := com.aj.CallMethod("IsScreenStuck", x1, y1, x2, y2, T)
	return int(int32(ret.Val))
}

/*
函数功能: 当图片缓存机制打开时,从文件加载图片到缓存

函数原型: 整数 LoadPic(PicName)

参数说明:
PicName: 字符串,包含路径的图片名称,如果设置了全局路径,则可以只给出图片名称,支持多个图片,绝对路径的格式为: "路径\PicName1.bmp|路径\PicName2.bmp|路径\PicName3.bmp|……", 相对路径的格式为: "PicName1.bmp|PicName2.bmp|PicName3.bmp|……",设置了全局路径后依然可以写成绝对路径的格式,并且可以绝对路径和相对路径任意组合.图片名中可以使用符号"*"和"?",示例说明如下:

"*.bmp" : 表示加载全局路径下所有的bmp文件,如果没有设置全局路径则要给出完整的路径
"1?2.bmp": 表示加载全局路径下所有第一个字符是1,第二个字符任意,第三个字符是2的bmp文件
"d*.bmp": 表示加载全局路径下所有以d字符开头的bmp文件
"1?23?4*.bmp": 表示加载全局路径下所有以字符串1?23?4开头并且第一个字符是1,第二个字符任意,第三个字符是2,第四个字符是3,第5个字符任意,第六个字符是4的bmp文件
这个参数可以是相对路径或绝对路径,含有或不含有符号"*"和"?"这样任意的组合.要从其它路径加载图片应该包含完整的路径

返回值: 整数,指定的图片都加载成功返回1,只要有1张图片加载失败就返回0

示例:
AJD = AJ.LoadPic("1?2.bmp|C:\Pic\1.bmp|d*.bmp")
AJD = AJ.LoadPic("C:\Pic\*.bmp")

如果图片用函数EncryptFile加密过,在调用此函数之前需要调用函数SetPicPw设置密码图片才能加载成功

如果只有在图片缓存机制打开时调用此函数才会加载图片,此函数完全可以不用主动调用,如果图片缓存机制是打开的,所有图片相关函数只要调用过一次图片就会加入缓存.SetPath设置的全局路径可以看成是所有要加载的文件的文件名的一部分,因为函数是通过包含完整路径的文件名在缓存中获取图片数据的,如果在加载完图片后改变了原先设置的全局路径,或没设置全局路径就把图片加载到缓存但后面设置的全局路径不能当成已加入缓存的图片的文件名的一部分,这时图片虽然在缓存中但函数就不能从缓存中获取图片数据,除非给出完整的绝对路径而不用相对路径,不过到对象释放时图片数据依然会被释放,因为对象销毁时自动释放图片不需要图片名.
*/
func (com *AJsoft) LoadPic(PicName string) int {
	ret, _ := com.aj.CallMethod("LoadPic", PicName)
	return int(ret.Val)
}

/*
函数功能: 当图片缓存机制打开时,从内存加载图片到缓存

函数原型: 整数 LoadPicM(Addr, PicName)

参数说明:
Addr: 64位长整数,图像数据在内存中的地址,这个地址的数据要符合24位位图格式,即包含正确的位图文件头和位图信息头以及颜色数据

PicName: 字符串,给这个数据地址指定一个图片名,接下来可以将这个图片名传递给找图函数找图,这个参数可以是相对路径或绝对路径,并且不能设为空.

返回值: 整数,返回1表示成功,0表示失败

示例:

	  LLAJD = AJ.GetScreenDataBmp(x1, y1, x2, y2, L"", Size);
	  if (LLAJD != 0) {
	    AJD = AJ.LoadPicM(LLAJD, L"LLAJD.bmp"); cout << "AJD: " << AJD << endl;
	    AJD = AJ.FindPic(0, 0, 1919, 1079, L"LLAJD.bmp", L"000000", 1.0, 9, 0, P, x, y); SAS = P; cout << SAS << " -> " << x << " , " << y << endl;
	  }
	函数会把地址Addr的图像数据拷贝到新开辟的缓存区域,对象释放时会自动释放这块新开辟的缓存区域

这个函数不支持加载加密过的图像数据
*/
func (com *AJsoft) LoadPicM(Addr int64, PicName string) int {
	ret, _ := com.aj.CallMethod("LoadPicM", Addr, PicName)
	return int(ret.Val)
}

/*
函数功能: 将其它图片格式转换为24位位图格式,支持把所有可以用画图保存的图片格式转换为24位位图格式

函数原型: 整数 PicToBmp(PicName, BmpName)

参数说明:
PicName: 字符串,包含路径的转换前的图片名称,如果设置了全局路径,则可以只给出图片名称,只能是一张图片

BmpName: 字符串,包含路径的转换后的图片名称,如果设置了全局路径,则可以只给出图片名称,只能是一张图片

返回值: 整数,返回1表示成功,0表示失败

示例:
AJD = AJ.PicToBmp("1.png", "2.bmp") : TracePrint AJD
AJD = AJ.PicToBmp("3.jpg", "4.bmp") : TracePrint AJD
AJD = AJ.PicToBmp("5.gif", "6.bmp") : TracePrint AJD
AJD = AJ.PicToBmp("7.tif", "8.bmp") : TracePrint AJD
*/
func (com *AJsoft) PicToBmp(PicName, BmpName string) int {
	ret, _ := com.aj.CallMethod("PicToBmp", PicName, BmpName)
	return int(ret.Val)
}

/*
函数功能: 截取桌面或后台窗口的指定区域的图像保存,保存格式由参数Type指定,可以是24位位图,png,jpg,gif格式的图片

函数原型: 整数 ScreenShot(x1, y1, x2, y2, PicName, Type, Quality, TD, T, Flag, Mouse)

参数说明:
x1: 整数,区域左上角的横坐标

y1: 整数,区域左上角的纵坐标

x2: 整数,区域右下角的横坐标

y2: 整数,区域右下角的纵坐标

PicName: 字符串,包含路径的要保存的图片名,如果设置了全局路径,则可以只给出图片名称,只能是一张图片

Type: 整数,决定要保存的图片的格式,只能是下面列出的值之一:

0: 将图片保存为24位位图,此时忽略参数Quality, TD, T
1: 将图片保存为png格式,此时忽略参数Quality, TD, T
2: 将图片保存为jpg格式,此时忽略参数TD, T
3: 将图片保存为gif格式,此时忽略参数Quality
Quality: 整数,jpg格式的图片的压缩比例,取值范围是[0, 100],只有Type设为2时才使用这个参数

TD: 无符号整数,截取动图的时间间隔,单位是毫秒,只能是大于等于0且小于等于T的整数.如果设为0,则将图片保存为静态的gif图片.如果时间太短,在短时间内会截取大量相同或相似的图片,播放时看起来会很卡,参考的设置时间范围是[50, 150].只有Type设为3时才使用这个参数

T: 无符号整数,截取动图的时间,单位是毫秒,只能是大于0的整数,只有Type设为3时才使用这个参数

Flag: 整数,决定当图色处于后台模式时的截图方式,取值只能是0或1,0表示无论图色处于什么后台模式都使用GDI方式截图,1表示使用对应的后台模式进行截图,当图色处于前台模式时忽略这个参数

Mouse: 整数,决定当图色处于前台模式时如果鼠标光标在截图区域画不画上光标,取值只能是0或1,0表示不画上光标,1表示画上光标,当图色处于后台模式时忽略这个参数

返回值: 整数,返回1表示成功,0表示失败

示例:
AJD = AJ.ScreenShot(1563, 669, 1911, 1031, "无.bmp", 0, 0, 0, 0, 0, 0) : TracePrint AJD
AJD = AJ.ScreenShot(1563, 669, 1911, 1031, "无.png", 1, 0, 0, 0, 1, 1) : TracePrint AJD
AJD = AJ.ScreenShot(1563, 669, 1911, 1031, "无.jpg", 2, 100, 0, 0, 0, 0) : TracePrint AJD
AJD = AJ.ScreenShot(0, 0, 1919, 1079, "C:\Users\Administrator\Desktop\无.gif", 3, 0, 100, 5000, 1, 0) : TracePrint AJD
*/
func (com *AJsoft) ScreenShot(x1, y1, x2, y2 int, PicName string, Type, Quality int, TD, T uint, Flag, Mouse int) int {
	ret, _ := com.aj.CallMethod("ScreenShot", x1, y1, x2, y2, PicName, Type, Quality, TD, T, Flag, Mouse)
	return int(ret.Val)
}
